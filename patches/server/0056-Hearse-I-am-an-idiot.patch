From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Mon, 9 Jan 2023 21:11:42 +0800
Subject: [PATCH] Hearse: I am an idiot

Original license: MIT
Original project: https://github.com/NaturalCodeClub/HearseRewrite

diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentArrayDeque.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentArrayDeque.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c29129dc02ddcfaad026d1f81e5da879a0d64cb
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentArrayDeque.java
@@ -0,0 +1,4 @@
+package net.himeki.mcmtfabric.parallelised;
+
+public class ConcurrentArrayDeque {
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
new file mode 100644
index 0000000000000000000000000000000000000000..67dd5fe624fe4428d8907000cb23a33485fd6bd9
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
@@ -0,0 +1,41 @@
+package net.himeki.mcmtfabric.parallelised;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+public class ConcurrentCollections {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static <T> Set<T> newHashSet() {
+        //LOGGER.info("Concurrent hash set created");
+        return Collections.newSetFromMap(new ConcurrentHashMap<T, Boolean>());
+    }
+
+    public static <T, U> Map<T, U> newHashMap() {
+        //LOGGER.info("Concurrent hash map created");
+        return new ConcurrentHashMap<T, U>();
+    }
+
+    public static <T> List<T> newLinkedList() {
+        LOGGER.info("Concurrent \"linked\" list created");
+        return new CopyOnWriteArrayList<T>();
+    }
+
+    public static <T> Collector<T, ?, List<T>> toList() {
+        return Collectors.toCollection(CopyOnWriteArrayList::new);
+    }
+
+    public static <T> Queue<T> newArrayDeque() {
+        LOGGER.info("Concurrent \"array\" deque created");
+        return new ConcurrentLinkedDeque<T>();
+    }
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
index 22b9d217dc06caaf8fbec21f0e31aa1cd13144ee..fec1f280c72c5b519173017877812ec3f7149ec5 100644
--- a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
@@ -10,19 +10,11 @@ package net.himeki.mcmtfabric.parallelised;
  * Modified to actually implement List<E>
  */
 
-import java.util.AbstractCollection;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.NoSuchElementException;
-import java.util.concurrent.atomic.AtomicReference;
-
 import org.apache.commons.lang3.NotImplementedException;
 
+import java.util.*;
+import java.util.concurrent.atomic.AtomicReference;
+
 /**
  * A concurrent linked-list implementation of a {@link Deque} (double-ended
  * queue). Concurrent insertion, removal, and access operations execute safely
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..586b3c87dcf010e2401933c5ec2338f59b9edad3
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
@@ -0,0 +1,230 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+public class ConcurrentLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    private final ConcurrentSkipListSet<Long> backing;
+
+    public ConcurrentLongLinkedOpenHashSet() {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial) {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public boolean add(final long k) {
+        boolean out = backing.add(k);
+		/*
+		if (!firstDef) {
+			first = k;
+			firstDef = true;
+		}
+		last = k;
+		*/
+        return out;
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        return addAll((Collection<Long>) c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Long> c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean addAndMoveToFirst(final long k) {
+        boolean out = backing.add(k);
+        //first = k;
+        return out;
+    }
+
+    @Override
+    public boolean addAndMoveToLast(final long k) {
+        boolean out = backing.add(k);
+        //last = k;
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public LongLinkedOpenHashSet clone() {
+        return new ConcurrentLongLinkedOpenHashSet(backing.iterator());
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+    @Override
+    public boolean contains(final long k) {
+        return backing.contains(k);
+    }
+
+    @Override
+    public long firstLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return first;
+		*/
+        return backing.first();
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public LongSortedSet headSet(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public LongListIterator iterator() {
+        return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public LongListIterator iterator(long from) {
+        throw new IllegalStateException();
+        //return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public long lastLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return last;
+		*/
+        return backing.last();
+    }
+
+    @Override
+    public boolean remove(final long k) {
+		/*
+		if (k == first) {
+			first = backing.iterator().next();
+		}
+		if (k == last) {
+			last = backing.iterator().next();
+		}
+		*/
+        return backing.remove(k);
+    }
+
+    @Override
+    public long removeFirstLong() {
+        long fl = this.firstLong();
+        this.remove(fl);
+        //first = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public long removeLastLong() {
+        long fl = this.lastLong();
+        this.remove(fl);
+        //last = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public LongSortedSet subSet(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet tailSet(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean trim() {
+        return true;
+    }
+
+    @Override
+    public boolean trim(final int n) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongSortedSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongSortedSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..93bd066ec2013e42a85fcf21344fe41f3ad69598
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongSortedSet.java
@@ -0,0 +1,144 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.*;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+public class ConcurrentLongSortedSet implements LongSortedSet {
+
+    ConcurrentSkipListSet<Long> back = new ConcurrentSkipListSet<>();
+
+    @Override
+    public LongBidirectionalIterator iterator(long fromElement) {
+        return null;
+    }
+
+    @Override
+    public int size() {
+        return back.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return back.isEmpty();
+    }
+
+    @Override
+    public LongBidirectionalIterator iterator() {
+        return null;
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return back.toArray();
+    }
+
+    @NotNull
+    @Override
+    public <T> T[] toArray(@NotNull T[] ts) {
+        return null;
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        return back.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends Long> collection) {
+        return back.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        return back.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        return back.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        back.clear();
+    }
+
+    @Override
+    public boolean add(long key) {
+        return back.add(key);
+    }
+
+    @Override
+    public boolean contains(long key) {
+        return back.contains(key);
+    }
+
+    @Override
+    public long[] toLongArray() {
+        return new long[0];
+    }
+
+    @Override
+    public long[] toArray(long[] a) {
+        return new long[0];
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        return back.addAll(c);
+    }
+
+    @Override
+    public boolean containsAll(LongCollection c) {
+        return back.containsAll(c);
+    }
+
+    @Override
+    public boolean removeAll(LongCollection c) {
+        return back.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(LongCollection c) {
+        return back.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(long k) {
+        return back.remove(k);
+    }
+
+    @Override
+    public LongSortedSet subSet(long fromElement, long toElement) {
+        return new LongAVLTreeSet(back.subSet(fromElement,toElement));
+    }
+
+    @Override
+    public LongSortedSet headSet(long toElement) {
+        return new LongAVLTreeSet(back.headSet(toElement));
+    }
+
+    @Override
+    public LongSortedSet tailSet(long fromElement) {
+        return new LongAVLTreeSet(back.tailSet(fromElement));
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+    @Override
+    public long firstLong() {
+        return back.first();
+    }
+
+    @Override
+    public long lastLong() {
+        return back.last();
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff1a4f87356459d3bc990a77c3081932046da5b1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
@@ -0,0 +1,112 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import it.unimi.dsi.fastutil.shorts.ShortSet;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ConcurrentShortHashSet implements ShortSet {
+
+    ConcurrentHashMap.KeySetView<Short, Boolean> backing = ConcurrentHashMap.newKeySet();
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public ShortIterator iterator() {
+        return new FastUtilHackUtil.WrappingShortIterator(backing.iterator());
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return backing.toArray();
+    }
+
+    @NotNull
+    @Override
+    public <T> T[] toArray(@NotNull T[] ts) {
+        return (T[]) backing.toArray();
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        return backing.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends Short> collection) {
+        return backing.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        return backing.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        return backing.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+
+    }
+
+    @Override
+    public boolean add(short key) {
+        return backing.add(key);
+    }
+
+    @Override
+    public boolean contains(short key) {
+        return backing.contains(key);
+    }
+
+    @Override
+    public short[] toShortArray() {
+        return new short[0];
+    }
+
+    @Override
+    public short[] toArray(short[] a) {
+        return new short[0];
+    }
+
+    @Override
+    public boolean addAll(ShortCollection c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean containsAll(ShortCollection c) {
+        return backing.containsAll(c);
+    }
+
+    @Override
+    public boolean removeAll(ShortCollection c) {
+        return backing.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(ShortCollection c) {
+        return backing.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(short k) {
+        return backing.remove(k);
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca1fd9ca6f5c5d5d4a0f374440ccaf80347fb781
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
@@ -0,0 +1,1678 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.bytes.ByteIterator;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import org.apache.commons.lang3.ArrayUtils;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public class FastUtilHackUtil {
+
+    public static class ConvertingObjectSet<E, T> implements ObjectSet<T> {
+
+        Set<E> backing;
+        Function<E, T> forward;
+        Function<T, E> back;
+
+        public ConvertingObjectSet(Set<E> backing, Function<E, T> forward, Function<T, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @Override
+        public boolean add(T e) {
+            return backing.add(back.apply(e));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends T> c) {
+            return backing.addAll(c.stream().map(i -> back.apply(i)).collect(Collectors.toSet()));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<T> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<T>() {
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public T next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+
+    }
+
+    public static class ConvertingObjectSetFast<E,T> implements Long2ObjectMap.FastEntrySet<T> {
+
+        Set<E> backing;
+        Function<E, Long2ObjectMap.Entry<T>> forward;
+        Function<Long2ObjectMap.Entry<T>, E> back;
+
+        public ConvertingObjectSetFast(Set<E> backing,
+                                       Function<E, Long2ObjectMap.Entry<T>> forward,
+                                       Function<Long2ObjectMap.Entry<T>, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back
+                                .apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<Long2ObjectMap.Entry<T>>() {
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public Long2ObjectMap.Entry<T> next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+        @Override
+        public boolean add(Long2ObjectMap.Entry<T> e) {
+            return backing.add(back.apply(e));
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long2ObjectMap.Entry<T>> c) {
+            return backing.addAll(c.stream().map(back).collect(Collectors.toList()));
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> fastIterator() {
+            return iterator();
+        }
+
+
+    }
+
+    private static <T> Entry<T> intEntryForwards(Map.Entry<Integer, T> entry) {
+        return new Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public int getIntKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Integer, T> intEntryBackwards(Entry<T> entry) {
+        return entry;
+    }
+
+    private static <T> Long2ObjectMap.Entry<T> longEntryForwards(Map.Entry<Long, T> entry) {
+        return new Long2ObjectMap.Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Long, T> longEntryBackwards(Long2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static Long2ByteMap.Entry longByteEntryForwards(Map.Entry<Long, Byte> entry) {
+        return new Long2ByteMap.Entry() {
+
+            @Override
+            public Byte getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public byte setValue(byte value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public byte getByteValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Byte> longByteEntryBackwards(Long2ByteMap.Entry entry) {
+        return entry;
+    }
+
+    private static Long2LongMap.Entry longLongEntryForwards(Map.Entry<Long, Long> entry) {
+        return new Long2LongMap.Entry() {
+
+            @Override
+            public Long getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long setValue(long value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Long> longLongEntryBackwards(Long2LongMap.Entry entry) {
+        return entry;
+    }
+
+    public static <T> ObjectSet<Entry<T>> entrySetIntWrap(Map<Integer, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Integer, T>, Entry<T>>(map.entrySet(), FastUtilHackUtil::intEntryForwards, FastUtilHackUtil::intEntryBackwards);
+    }
+
+    public static <T> ObjectSet<Long2ObjectMap.Entry<T>> entrySetLongWrap(Map<Long, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, T>, Long2ObjectMap.Entry<T>>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static <T> Long2ObjectMap.FastEntrySet<T> entrySetLongWrapFast(Map<Long, T> map) {
+        return new ConvertingObjectSetFast<Map.Entry<Long, T>, T>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static ObjectSet<Long2ByteMap.Entry> entrySetLongByteWrap(Map<Long, Byte> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Byte>, Long2ByteMap.Entry>(map.entrySet(), FastUtilHackUtil::longByteEntryForwards, FastUtilHackUtil::longByteEntryBackwards);
+    }
+
+    public static ObjectSet<Long2LongMap.Entry> entrySetLongLongWrap(Map<Long, Long> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Long>, Long2LongMap.Entry>(map.entrySet(), FastUtilHackUtil::longLongEntryForwards, FastUtilHackUtil::longLongEntryBackwards);
+    }
+
+
+    static class WrappingIntIterator implements IntIterator {
+
+        Iterator<Integer> backing;
+
+        public WrappingIntIterator(Iterator<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public int nextInt() {
+            return backing.next();
+        }
+
+        @Override
+        public Integer next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingLongIterator implements LongIterator {
+
+        Iterator<Long> backing;
+
+        public WrappingLongIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public Long next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingShortIterator implements ShortIterator {
+
+        Iterator<Short> backing;
+
+        public WrappingShortIterator(Iterator<Short> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public short nextShort() {
+            return backing.next();
+        }
+
+        @Override
+        public Short next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    public static class WrappingIntSet implements IntSet {
+
+        Set<Integer> backing;
+
+        public WrappingIntSet(Set<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(int key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(int key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return backing.stream().mapToInt(i -> i).toArray();
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toIntArray();
+            }
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return toIntArray(a);
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return new WrappingIntIterator(backing.iterator());
+        }
+
+        @Override
+        public boolean remove(int k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSet wrapLongSet(Set<Long> longset) {
+        return new WrappingLongSet(longset);
+    }
+
+    public static class WrappingLongSet implements LongSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return new WrappingLongIterator(backing.iterator());
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSortedSet wrapLongSortedSet(Set<Long> longset) {
+        return new WrappingLongSortedSet(longset);
+    }
+
+    public static class WrappingLongSortedSet implements LongSortedSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSortedSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator(long fromElement) {
+            throw new UnsupportedOperationException();
+            //return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator() {
+            return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongSortedSet subSet(long fromElement, long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet headSet(long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet tailSet(long fromElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongComparator comparator() {
+            return null;
+        }
+
+        @Override
+        public long firstLong() {
+            return backing.stream().findAny().get();
+        }
+
+        @Override
+        public long lastLong() {
+            return backing.stream().findAny().get();
+        }
+
+    }
+
+    public static IntSet wrapIntSet(Set<Integer> intset) {
+        return new WrappingIntSet(intset);
+    }
+
+    public static class WrappingObjectCollection<V> implements ObjectCollection<V> {
+
+        Collection<V> backing;
+
+        public WrappingObjectCollection(Collection<V> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(V e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<V> iterator() {
+            return FastUtilHackUtil.itrWrap(backing);
+        }
+
+    }
+
+    public static <K> ObjectCollection<K> wrap(Collection<K> c) {
+        return new WrappingObjectCollection<K>(c);
+    }
+
+    public static class WrappingByteCollection implements ByteCollection {
+
+        Collection<Byte> backing;
+
+        public WrappingByteCollection(Collection<Byte> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(byte o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(byte e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Byte> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ByteIterator iterator() {
+            return FastUtilHackUtil.itrByteWrap(backing);
+        }
+
+        @Override
+        public boolean rem(byte key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public byte[] toByteArray() {
+            return null;
+        }
+
+        @Override
+        public byte[] toByteArray(byte[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public byte[] toArray(byte[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Byte[0]));
+        }
+
+        @Override
+        public boolean addAll(ByteCollection c) {
+            return addAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean containsAll(ByteCollection c) {
+            return containsAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean removeAll(ByteCollection c) {
+            return removeAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean retainAll(ByteCollection c) {
+            return retainAll((Collection<Byte>) c);
+        }
+
+    }
+
+    public static ByteCollection wrapBytes(Collection<Byte> c) {
+        return new WrappingByteCollection(c);
+    }
+
+    public static class WrappingIntCollection implements IntCollection {
+
+        Collection<Integer> backing;
+
+        public WrappingIntCollection(Collection<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(int o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(int e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return FastUtilHackUtil.itrIntWrap(backing);
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return null;
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return addAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return containsAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return removeAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return retainAll((Collection<Integer>) c);
+        }
+
+    }
+
+    public static IntCollection wrapInts(Collection<Integer> c) {
+        return new WrappingIntCollection(c);
+    }
+
+    public static class WrappingLongCollection implements LongCollection {
+
+        Collection<Long> backing;
+
+        public WrappingLongCollection(Collection<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(long o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(long e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return FastUtilHackUtil.itrLongWrap(backing);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return null;
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Long[0]));
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return addAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return containsAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return removeAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return retainAll((Collection<Long>) c);
+        }
+
+    }
+
+    public static LongCollection wrapLongs(Collection<Long> c) {
+        return new WrappingLongCollection(c);
+    }
+
+
+    public static class WrappingLongListIterator implements LongListIterator {
+
+        ListIterator<Long> backing;
+
+        public WrappingLongListIterator(ListIterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            return backing.previous();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return backing.hasPrevious();
+        }
+
+        @Override
+        public int nextIndex() {
+            return backing.nextIndex();
+        }
+
+        @Override
+        public int previousIndex() {
+            return backing.previousIndex();
+        }
+
+        @Override
+        public void add(long k) {
+            backing.add(k);
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(long k) {
+            backing.set(k);
+        }
+    }
+
+    public static class SlimWrappingLongListIterator implements LongListIterator {
+
+        Iterator<Long> backing;
+
+        public SlimWrappingLongListIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int nextIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int previousIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void add(long k) {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(long k) {
+            throw new IllegalStateException();
+        }
+    }
+
+    public static LongListIterator wrap(ListIterator<Long> c) {
+        return new WrappingLongListIterator(c);
+    }
+
+    public static LongListIterator wrap(Iterator<Long> c) {
+        return new SlimWrappingLongListIterator(c);
+    }
+
+    public static class WrappingByteIterator implements ByteIterator {
+
+        Iterator<Byte> parent;
+
+        public WrappingByteIterator(Iterator<Byte> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Byte next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public byte nextByte() {
+            return next();
+        }
+
+    }
+
+    public static ByteIterator itrByteWrap(Iterator<Byte> backing) {
+        return new WrappingByteIterator(backing);
+    }
+
+    public static ByteIterator itrByteWrap(Iterable<Byte> backing) {
+        return new WrappingByteIterator(backing.iterator());
+    }
+
+    public static IntIterator itrIntWrap(Iterator<Integer> backing) {
+        return new WrappingIntIterator(backing);
+    }
+
+    public static IntIterator itrIntWrap(Iterable<Integer> backing) {
+        return new WrappingIntIterator(backing.iterator());
+    }
+
+    public static LongIterator itrLongWrap(Iterator<Long> backing) {
+        return new WrappingLongIterator(backing);
+    }
+
+    public static LongIterator itrLongWrap(Iterable<Long> backing) {
+        return new WrappingLongIterator(backing.iterator());
+    }
+
+    public static ShortIterator itrShortWrap(Iterator<Short> backing) {
+        return new WrappingShortIterator(backing);
+    }
+
+    public static ShortIterator itrShortWrap(Iterable<Short> backing) {
+        return new WrappingShortIterator(backing.iterator());
+    }
+
+    public static class WrapperObjectIterator<T> implements ObjectIterator<T> {
+
+        Iterator<T> parent;
+
+        public WrapperObjectIterator(Iterator<T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public T next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+    }
+
+    public static class IntWrapperEntry<T> implements Entry<T> {
+
+        Map.Entry<Integer, T> parent;
+
+        public IntWrapperEntry(Map.Entry<Integer, T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public T getValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public T setValue(T value) {
+            return parent.setValue(value);
+        }
+
+        @Override
+        public int getIntKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public Integer getKey() {
+            return parent.getKey();
+        }
+
+    }
+
+    public static class Long2IntWrapperEntry implements Long2IntMap.Entry {
+
+        Map.Entry<Long, Integer> parent;
+
+        public Long2IntWrapperEntry(Map.Entry<Long, Integer> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public long getLongKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public int getIntValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public int setValue(int value) {
+            return parent.setValue(value);
+        }
+
+
+    }
+
+    public static class WrapperIntEntryObjectIterator<T> implements ObjectIterator<Entry<T>> {
+
+        Iterator<Map.Entry<Integer, T>> parent;
+
+        public WrapperIntEntryObjectIterator(Iterator<Map.Entry<Integer, T>> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Entry<T> next() {
+            Map.Entry<Integer, T> val = parent.next();
+            if (val == null) return null;
+            return new IntWrapperEntry<T>(val);
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+    }
+
+    public static <T> ObjectIterator<Entry<T>> intMapItrFake(Map<Integer, T> in) {
+        return new WrapperIntEntryObjectIterator<T>(in.entrySet().iterator());
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterator<T> in) {
+        return new WrapperObjectIterator<T>(in);
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterable<T> in) {
+        return new WrapperObjectIterator<T>(in.iterator());
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb6c592fd34423fdd910feae83a058d288da537a
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
@@ -0,0 +1,93 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import org.apache.commons.lang3.NotImplementedException;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Int2ObjectConcurrentHashMap<V> implements Int2ObjectMap<V> {
+
+    Map<Integer, V> backing;
+
+    public Int2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Integer, V>();
+    }
+
+    @Override
+    public V get(int key) {
+        return backing.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Integer, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        throw new NotImplementedException("MCMT - Not implemented");
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> int2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetIntWrap(backing);
+    }
+
+
+    @Override
+    public IntSet keySet() {
+        return FastUtilHackUtil.wrapIntSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(int key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V put(Integer key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V remove(int key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void clear() { backing.clear(); }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0fab16860e1be817fd10dbec684f295f2e291dd
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
@@ -0,0 +1,99 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ByteConcurrentHashMap implements Long2ByteMap {
+
+    Map<Long, Byte> backing;
+    byte defaultReturn = 0;
+    byte nullKey = 0;
+
+    public Long2ByteConcurrentHashMap() {
+        backing = new ConcurrentHashMap<>();
+    }
+
+    public Long2ByteConcurrentHashMap(int initialCapacity, float loadFactor) {
+        backing = new ConcurrentHashMap<>(initialCapacity, loadFactor);
+    }
+
+    @Override
+    public byte get(long key) {
+        Byte out = backing.get(key);
+        return out == null ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(byte value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Byte> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(byte rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public byte defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2ByteEntrySet() {
+        return FastUtilHackUtil.entrySetLongByteWrap(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ByteCollection values() {
+        return FastUtilHackUtil.wrapBytes(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public byte put(long key, byte value) {
+        return put((Long) key, (Byte) value);
+    }
+
+    @Override
+    public Byte put(Long key, Byte value) {
+        Byte out = backing.put(key, value);
+        return out == null ? Byte.valueOf(defaultReturn) : out;
+    }
+
+    @Override
+    public byte remove(long key) {
+        Byte out = backing.remove(key);
+        return out == null ? defaultReturn : out;
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..261f06a88021a95b6a0500444665547aeb4ae2c1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
@@ -0,0 +1,74 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2IntConcurrentHashMap implements Long2IntMap {
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+    int defaultRV = 0;
+
+    @Override
+    public int get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(int rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public int defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2IntEntrySet() {
+        return null;
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(int value) {
+        return backing.containsValue(value);
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc2342486318721d399c7c60a0a859befb4d1c9f
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
@@ -0,0 +1,375 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+@SuppressWarnings("deprecation")
+public class Long2IntConcurrentNonLinkedOpenMap extends Long2IntLinkedOpenHashMap {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -2082212127278131631L;
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected, final float f) {
+
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     *
+     * @param expected the expected number of elements in the hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected) {
+    }
+
+    /**
+     * Creates a new hash map with initial expected
+     * {@link Hash#DEFAULT_INITIAL_SIZE} entries and
+     * {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap() {
+    }
+
+    /**
+     * Creates a new hash map copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m, final float f) {
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m, final float f) {
+        this(m.size(), f);
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @param f the load factor.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v, final float f) {
+        if (k.length != v.length)
+            throw new IllegalArgumentException(
+                    "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
+        for (int i = 0; i < k.length; i++)
+            this.put(k[i], v[i]);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v) {
+        this(k, v, DEFAULT_LOAD_FACTOR);
+    }
+
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    public int put(final long k, final int v) {
+        Integer out = backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int addTo(final long k, final int incr) {
+        Integer out =  backing.put(k, this.get(k)+incr);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int remove(final long k) {
+        Integer out = backing.remove(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeFirstInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeLastInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int getAndMoveToFirst(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int getAndMoveToLast(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToFirst(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToLast(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int get(final long k) {
+        Integer out =  backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public boolean containsKey(final long k) {
+        return backing.containsKey(k);
+    }
+
+    public boolean containsValue(final int v) {
+        return backing.containsValue(v);
+    }
+
+    public int getOrDefault(final long k, final int defaultValue) {
+        Integer out =  backing.getOrDefault(k, defaultValue);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putIfAbsent(final long k, final int v) {
+        Integer out =  backing.putIfAbsent(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public boolean remove(final long k, final int v) {
+        return backing.remove(k, v);
+    }
+
+
+    public boolean replace(final long k, final int oldValue, final int v) {
+        return  backing.replace(k, oldValue, v);
+    }
+
+
+    public int replace(final long k, final int v) {
+        Integer out = backing.replace(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsent(final long k, final java.util.function.LongToIntFunction mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.applyAsInt(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsentNullable(final long k,
+                                       final java.util.function.LongFunction<? extends Integer> mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.apply(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfPresent(final long k,
+                                final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        if (this.containsKey(k)) {
+            Integer out =  backing.put(k, remappingFunction.apply(k, backing.get(k)));
+            if (out == null) {
+                return defRetValue;
+            }
+            return out;
+        }
+        return defaultReturnValue();
+
+    }
+
+    @Override
+    public int compute(final long k,
+                       final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out =  backing.compute(k, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    @Override
+    public int merge(final long k, final int v,
+                     final java.util.function.BiFunction<? super Integer, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out =  backing.merge(k, v, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long firstLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public long lastLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public Long2IntSortedMap tailMap(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap headMap(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap subMap(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+
+    @Override
+    public FastSortedEntrySet long2IntEntrySet() {
+        //TODO implement
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet keySet() {
+        return FastUtilHackUtil.wrapLongSortedSet(backing.keySet());
+    }
+
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    public boolean trim() {
+        return true;
+    }
+
+    public boolean trim(final int n) {
+        return true;
+    }
+
+
+    @Override
+    public Long2IntConcurrentNonLinkedOpenMap clone() {
+        return new Long2IntConcurrentNonLinkedOpenMap(backing);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..3205d30a03f99caf7dfa05237b2bc31182b2db20
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
@@ -0,0 +1,97 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public class Long2LongConcurrentHashMap implements Long2LongMap {
+
+    public Map<Long, Long> backing = new ConcurrentHashMap<Long, Long>();
+    long defaultRV = 0;
+
+    public Long2LongConcurrentHashMap(long defaultRV) {
+        this.defaultRV = defaultRV;
+    }
+
+    @Override
+    public long get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long put(final long key, final long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long put(final Long key, final Long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public long remove(final long key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Long> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(long rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public long defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2LongEntrySet() {
+        return FastUtilHackUtil.entrySetLongLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public LongCollection values() {
+        return FastUtilHackUtil.wrapLongs(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(long value) {
+        return backing.containsValue(value);
+    }
+
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5ed71564d4c9a986f77cbc0397130aa38f97a91
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
@@ -0,0 +1,93 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ObjectConcurrentHashMap<V> implements Long2ObjectMap<V> {
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7d6be048ab3b8bd38231fce16eca0ac78e24690
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
@@ -0,0 +1,233 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectFunction;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Function;
+
+public class Long2ObjectOpenConcurrentHashMap<V> extends Long2ObjectOpenHashMap<V> {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -121514116954680057L;
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectOpenConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public V get(Object key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public FastEntrySet<V> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrapFast(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean trim() { return true; }
+
+    @Override
+    public boolean trim(final int n) { return true; }
+
+    @Override
+    public boolean replace(final long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    @Override
+    public V replace(final long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    @Override
+    public boolean replace(final Long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    @Override
+    public V replace(final Long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    @Override
+    public boolean remove(final long k, final Object v) {
+        return backing.remove(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final Long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    @Override
+    public V merge(final long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public V merge(Long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public V getOrDefault(final long k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    @Override
+    public V getOrDefault(Object k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    @Override
+    public V computeIfPresent(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    @Override
+    public V computeIfAbsent(final long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    public V computeIfAbsent(final Long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    @Override
+    public V computeIfAbsentPartial(final long key, final Long2ObjectFunction<? extends V> mappingFunction) {
+        if (!mappingFunction.containsKey(key))
+            return defaultReturn;
+        return backing.computeIfAbsent(key, (llong) -> mappingFunction.apply(llong));
+    }
+
+    @Override
+    public V compute(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public V compute(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public Long2ObjectOpenHashMap<V> clone() {
+        throw new IllegalArgumentException();
+    }
+
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return new FastUtilHackUtil.ConvertingObjectSet<Map.Entry<Long, V>, Map.Entry<Long, V>>(backing.entrySet(), Function.identity(), Function.identity());
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        return backing.remove(key, value);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d65e9575389a170e8b8465b1221a6e319749eb1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
@@ -0,0 +1,190 @@
+package net.himeki.mcmtfabric.parallelised.fastutil.sync;
+
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+public class SyncLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    public SyncLongLinkedOpenHashSet() {
+        super();
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial) {
+        super(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public synchronized boolean add(final long k) {
+        return super.add(k);
+    }
+
+    @Override
+    public synchronized boolean addAll(LongCollection c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAll(Collection<? extends Long> c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToFirst(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToLast(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized void clear() {
+        super.clear();
+    }
+
+    @Override
+    public synchronized LongLinkedOpenHashSet clone() {
+        return new SyncLongLinkedOpenHashSet(this);
+    }
+
+    @Override
+    public synchronized LongComparator comparator() {
+        return super.comparator();
+    }
+
+    @Override
+    public synchronized boolean contains(final long k) {
+        return super.contains(k);
+    }
+
+    @Override
+    public synchronized long firstLong() {
+        return super.firstLong();
+    }
+
+    @Override
+    public synchronized int hashCode() {
+        return super.hashCode();
+    }
+
+    @Override
+    public synchronized LongSortedSet headSet(long to) {
+        return super.headSet(to);
+    }
+
+    @Override
+    public synchronized boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator() {
+        return super.iterator();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator(long from) {
+        return super.iterator(from);
+    }
+
+    @Override
+    public synchronized long lastLong() {
+        return super.lastLong();
+    }
+
+    @Override
+    public synchronized boolean remove(final long k) {
+        return super.remove(k);
+    }
+
+    @Override
+    public synchronized long removeFirstLong() {
+        return super.removeFirstLong();
+    }
+
+    @Override
+    public synchronized long removeLastLong() {
+        return super.removeLastLong();
+    }
+
+    @Override
+    public synchronized int size() {
+        return super.size();
+    }
+
+    @Override
+    public synchronized LongSortedSet subSet(long from, long to) {
+        return super.subSet(from, to);
+    }
+
+    @Override
+    public synchronized LongSortedSet tailSet(long from) {
+        return super.tailSet(from);
+    }
+
+    @Override
+    public synchronized boolean trim() {
+        return super.trim();
+    }
+
+    @Override
+    public synchronized boolean trim(final int n) {
+        return super.trim(n);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 4beaa69da4001fc2723e9628d64bd3de728d7213..ebb1c69f905ef3c948a65c9f095244b7e663b3a9 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -2,9 +2,7 @@ package net.minecraft.server.level;
 
 import com.mojang.datafixers.util.Either;
 import com.mojang.datafixers.util.Pair;
-import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import it.unimi.dsi.fastutil.shorts.ShortSets;
 import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentShortHashSet;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -22,6 +20,7 @@ import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.*;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+
 import javax.annotation.Nullable;
 import java.util.BitSet;
 import java.util.List;
